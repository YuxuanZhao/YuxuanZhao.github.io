<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Vue 特性Promise先有一个promise，可能会花很长时间才能知道结果（pending），结果可能会成功（resolved）或者失败（rejected）。然后我们用then去接resolve返回的内容，用catch去接reject返回的内容。 1234567891011121314&#x2F;&#x2F;创建一个Promise实例const willIGetNewPhone &#x3D; new Promise((re">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue notes">
<meta property="og:url" content="http://yoursite.com/2020/09/01/Vue-notes/index.html">
<meta property="og:site_name" content="Eason Chiu">
<meta property="og:description" content="Vue 特性Promise先有一个promise，可能会花很长时间才能知道结果（pending），结果可能会成功（resolved）或者失败（rejected）。然后我们用then去接resolve返回的内容，用catch去接reject返回的内容。 1234567891011121314&#x2F;&#x2F;创建一个Promise实例const willIGetNewPhone &#x3D; new Promise((re">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/Users/easonchiu/Library/Application%20Support/typora-user-images/截屏2020-08-27%20上午8.38.52.png">
<meta property="article:published_time" content="2020-09-01T14:48:21.000Z">
<meta property="article:modified_time" content="2020-09-01T14:48:52.277Z">
<meta property="article:author" content="Eason">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/Users/easonchiu/Library/Application%20Support/typora-user-images/截屏2020-08-27%20上午8.38.52.png">
    
    
        
          
              <link rel="shortcut icon" href="../images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="../images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Vue notes</title>
    <!-- styles -->
    
<link rel="stylesheet" href="../lib/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="../lib/meslo-LG/styles.css">

    
<link rel="stylesheet" href="../lib/justified-gallery/justifiedGallery.min.css">

    
<link rel="stylesheet" href="../css/style.css">

    <!-- rss -->
    
    
    <!-- jquery -->
    
<script src="../lib/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
    <div class="banner">
<div id="blogtitel" class="blogtitel">Eason Chiu</div>
<ul id="wrapper" class="wrapper">
  <div class="sun">
    <div class="star"></div>
  </div>
  <div class="mercury">
    <div class="planet">
      <div class="shadow"></div>
    </div>
  </div>
  <div class="venus">
    <div class="planet">
      <div class="shadow"></div>
    </div>
  </div>
  <div class="earth">
    <div class="planet"><div class="shadow"></div></div>
  </div>
  <div class="mars">
    <div class="planet"><div class="shadow"></div></div>
  </div>
  <div class="jupiter">
    <div class="planet"><div class="shadow"></div></div>
  </div>
</ul>
</div>

    <div class="background">
      
        <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="../home/">Home</a></li>
         
          <li><a href="../about/">About</a></li>
         
          <li><a href="../archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/tzvetkov75">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="../2020/09/01/Network-notes/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2020/09/01/Vue-notes/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yoursite.com/2020/09/01/Vue-notes/&text=Vue notes"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2020/09/01/Vue-notes/&title=Vue notes"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2020/09/01/Vue-notes/&is_video=false&description=Vue notes"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Vue notes&body=Check out this article: http://yoursite.com/2020/09/01/Vue-notes/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yoursite.com/2020/09/01/Vue-notes/&title=Vue notes"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yoursite.com/2020/09/01/Vue-notes/&title=Vue notes"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2020/09/01/Vue-notes/&title=Vue notes"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yoursite.com/2020/09/01/Vue-notes/&title=Vue notes"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2020/09/01/Vue-notes/&name=Vue notes&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">Vue 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-number">1.1.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-gt-Observable"><span class="toc-number">1.1.1.</span> <span class="toc-text">Promise &#x3D;&gt; Observable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-number">1.2.</span> <span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E9%9D%A2-SPA"><span class="toc-number">1.3.</span> <span class="toc-text">单页面 SPA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">1.4.</span> <span class="toc-text">虚拟DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Key%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">Key的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data"><span class="toc-number">1.5.</span> <span class="toc-text">Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex"><span class="toc-number">1.6.</span> <span class="toc-text">vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-SSR"><span class="toc-number">1.7.</span> <span class="toc-text">Vue SSR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router"><span class="toc-number">1.8.</span> <span class="toc-text">vue-router</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-3-0"><span class="toc-number">1.9.</span> <span class="toc-text">Vue 3.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.10.</span> <span class="toc-text">文件结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E5%90%AC-%E6%9B%B4%E6%96%B0"><span class="toc-number">2.</span> <span class="toc-text">监听&#x2F;更新</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#computed-vs-watch"><span class="toc-number">2.1.</span> <span class="toc-text">computed vs watch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%88%B0%E7%9A%84%E6%95%B0%E7%BB%84%E5%8F%98%E5%8A%A8"><span class="toc-number">2.2.</span> <span class="toc-text">Vue 检测不到的数组变动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy-vs-Object-defineProperty"><span class="toc-number">2.3.</span> <span class="toc-text">Proxy vs Object.defineProperty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-set-vm-set"><span class="toc-number">2.4.</span> <span class="toc-text">Vue.set() &#x3D; vm.$set()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">父子组件的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.2.</span> <span class="toc-text">父组件监听子组件的生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Component-%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">4.1.</span> <span class="toc-text">Component 的单向数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">4.2.</span> <span class="toc-text">Vue 组件间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slot-vs-props"><span class="toc-number">4.3.</span> <span class="toc-text">slot vs props</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C"><span class="toc-number">4.4.</span> <span class="toc-text">全局&#x2F;局部注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive"><span class="toc-number">4.5.</span> <span class="toc-text">keep-alive</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#is"><span class="toc-number">5.1.</span> <span class="toc-text">is</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class%EF%BC%8Cstyle%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">5.2.</span> <span class="toc-text">class，style的动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-show-vs-v-if"><span class="toc-number">5.3.</span> <span class="toc-text">v-show vs v-if</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-model-%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text">v-model 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">双向绑定原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TodoList-%E5%AE%9E%E6%88%98"><span class="toc-number">6.</span> <span class="toc-text">TodoList 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%B8%80%E9%A1%B9"><span class="toc-number">6.1.</span> <span class="toc-text">完成一项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E9%A1%B9"><span class="toc-number">6.2.</span> <span class="toc-text">删除一项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Axios"><span class="toc-number">6.3.</span> <span class="toc-text">Axios</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">代码优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack-%E4%BC%98%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">Webpack 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack-%E5%9F%BA%E7%A1%80"><span class="toc-number">7.2.1.</span> <span class="toc-text">Webpack 基础</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.</span> <span class="toc-text">Web 优化</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

      
      <div class="content index width mx-auto px2 my4">
          
          <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Vue notes
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Eason Chiu</span>
      </span>
      
    <div class="postdate">
        <time datetime="2020-09-01T14:48:21.000Z" itemprop="datePublished">2020-09-01</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="Vue-特性"><a href="#Vue-特性" class="headerlink" title="Vue 特性"></a>Vue 特性</h1><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>先有一个promise，可能会花很长时间才能知道结果（pending），结果可能会成功（resolved）或者失败（rejected）。然后我们用then去接resolve返回的内容，用catch去接reject返回的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Promise实例</span></span><br><span class="line"><span class="keyword">const</span> willIGetNewPhone = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//在合适的时候resolve(successMessage)或者reject(new Error(&#x27;Mom is unhappy&#x27;))</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> askMom = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  willIGetNewPhone <span class="comment">//使用Promise实例</span></span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">fulfilled</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(fulfilled)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error.message)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">askMom()</span><br></pre></td></tr></table></figure>

<p>串联Promise:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> askMom = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1. Before asking&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  willIGetNewPhone <span class="comment">//Promise实例</span></span><br><span class="line">    .then(showOff) </span><br><span class="line">      <span class="comment">//第一个Promise成功了，把返回的参数放到这一个函数中，获得第二个Promise实例</span></span><br><span class="line">    .then(<span class="function"><span class="params">fulfilled</span> =&gt;</span> <span class="built_in">console</span>.log(fulfilled)) </span><br><span class="line">      <span class="comment">//第二个Promise成功了，返回信息</span></span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error.message));</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;2. After asking&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在将调用添加到回调链之后，<code>await X()</code> <em>暂停</em>当前函数的执行，而<code>promise.then(X)</code> <em>继续</em>执行当前函数<code>X</code>，await的空间和时间效率会更高。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用ES7改造</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">askMom</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//使用try&#123;&#125;catch(err)&#123;&#125;的方式来代替.then().catch()</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;before asking Mom&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> phone = <span class="keyword">await</span> willIGetNewPhone; <span class="comment">//这个Promise成功的消息不是马上能得到的，加上await</span></span><br><span class="line">    <span class="keyword">let</span> message = <span class="keyword">await</span> showOff(phone); <span class="comment">//这个showOff(phone)的成功消息也不是马上能拿到的，加上await</span></span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;after asking mom&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个async匿名函数，里面askMon()的结果是需要等待的，加上await，用括号括起来后面再加上括号代表马上运行这个函数</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> askMom();</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="Promise-gt-Observable"><a href="#Promise-gt-Observable" class="headerlink" title="Promise =&gt; Observable"></a>Promise =&gt; Observable</h3><p>Observable 是可以被取消，且在需要時才會執行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Observable = Rx.Observable</span><br><span class="line"><span class="keyword">let</span> resultA, resultB, resultC</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAsync</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = fetch(<span class="string">`http://example.com?num1=<span class="subst">$&#123;num1&#125;</span>&amp;num2=<span class="subst">$&#123;num2&#125;</span>`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">x</span> =&gt;</span> x.json())</span><br><span class="line">  <span class="keyword">return</span> Observable.fromPromise(promise); <span class="comment">//把promise转换成observable stream</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addAsync(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  .do(<span class="function"><span class="params">x</span> =&gt;</span> resultA = x)<span class="comment">//把结果传到resultA</span></span><br><span class="line">  .flatMap(<span class="function"><span class="params">x</span> =&gt;</span> addAsync(x, <span class="number">3</span>)) <span class="comment">//+3得到一个新的Promise</span></span><br><span class="line">  .do(<span class="function"><span class="params">x</span> =&gt;</span> resultB = x)<span class="comment">//把结果传到resultB</span></span><br><span class="line">  .flatMap(<span class="function"><span class="params">x</span> =&gt;</span> addAsync(x, <span class="number">4</span>))<span class="comment">//+4得到一个新的Promise</span></span><br><span class="line">  .do(<span class="function"><span class="params">x</span> =&gt;</span> resultC = x)<span class="comment">//把结果传到resultC</span></span><br><span class="line">  .subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="comment">//需要时执行（lazy）的意思是只在使用 .subscribe 时才开始执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;total&#x27;</span>, x)</span><br><span class="line">    conosle.log(resultA, resultB, resultC)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>View–ViewModel-Model</p>
<p>View 是视图层，也就是用户界面</p>
<p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p>
<p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，这样的封装使得 ViewModel 可以完整地去描述 View 层。</p>
<p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p>
<h2 id="单页面-SPA"><a href="#单页面-SPA" class="headerlink" title="单页面 SPA"></a>单页面 SPA</h2><p>仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>基于上面一点，SPA 相对对服务器压力小；</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>Document Object Model (DOM) 就是将HTML看作树形结构的API，每个节点代表了HTML的一个对象。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DOM 允许我们通过Javascript编程的方式改变文档的结构，样式，内容。搜索和更新真正的DOM是Web应用性能的瓶颈。</p>
<p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<ul>
<li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
<li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
<li>patch 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。<ul>
<li>初次渲染的时候，将VDOM渲染成真正的DOM然后插入到容器中</li>
<li>再次渲染的时候，将新旧vnode做diff算法，递归地找到同级间的diff，最终将差异应用到真正的DOM树上</li>
</ul>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
</ul>
<h3 id="Key的作用"><a href="#Key的作用" class="headerlink" title="Key的作用"></a>Key的作用</h3><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和  oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。</p>
<p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速：</p>
<p><strong>更准确</strong>：因为带 key 就不是就地复用了，在 sameNode 函数 <code>a.key === b.key</code> 对比中可以避免就地复用的情况。所以会更加准确。</p>
<p><strong>更快速</strong>：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</p>
<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>组件中的data需要写成一个function返回需要的值，因为如果写成data: {count: 0}的话，所有的事例的数据将会互相影响。new Vue可以写成一个对象，因为不会复用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  template: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>
<ul>
<li>State：应用级别的状态/数据</li>
<li>Getters：获取一部分的State或者State的计算后的值</li>
<li>Actions：组件调用来commit mutation</li>
<li>Mutations：改变State/更新数据</li>
<li>Modules：每一个module（比如post，auth module）都可以有自己的state，getters，actions，mutations</li>
</ul>
<h2 id="Vue-SSR"><a href="#Vue-SSR" class="headerlink" title="Vue SSR"></a>Vue SSR</h2><p>vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
<p><strong>（1）服务端渲染的优点：</strong></p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>
<p><strong>（2) 服务端渲染的缺点：</strong></p>
<ul>
<li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>1）新建<code>router.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用所需要的component</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./views/Home.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;./views/About.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router); <span class="comment">//使用vue-router</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导出router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">            component: Home<span class="comment">//使用component</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">            component: About<span class="comment">//使用component</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2）<code>main.js</code>中使用<code>router.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    router, <span class="comment">//router: router的缩写</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>3）<code>App.vue</code>使用vue-router的特定component<code>router-link</code>和<code>router-view</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span> = <span class="string">&quot;/&quot;</span>&gt;</span> Home <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span> = <span class="string">&quot;/about&quot;</span>&gt;</span> About <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>path: &#39;/about/:todoId&#39;</code>, 使用 <code>:todoId</code> 匹配任何的参数并将其保存在<code>$route.params.todoId</code>中</p>
</li>
<li><p>监听$route有没有变化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123; </span><br><span class="line">      <span class="string">&#x27;$route&#x27;</span> (to, <span class="keyword">from</span>)&#123;</span><br><span class="line">        alert(to.params.todoId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套路由就是增加了children[]，而且里面还可以再嵌套children[]</p>
</li>
</ul>
<p>三种模式：history，hash，abstract</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;history&#x27;</span>: <span class="comment">//第一种：依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式</span></span><br><span class="line">    <span class="built_in">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="built_in">this</span>, options.base)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;hash&#x27;</span>: <span class="comment">//第二种：使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器</span></span><br><span class="line">    <span class="built_in">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="built_in">this</span>, options.base, <span class="built_in">this</span>.fallback)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;abstract&#x27;</span>: <span class="comment">//第三种：支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式</span></span><br><span class="line">    <span class="built_in">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="built_in">this</span>, options.base)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      assert(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hash 模式的实现原理：</p>
<p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.word.com#search</span></span><br></pre></td></tr></table></figure>

<p>hash  路由模式的实现主要是基于下面几个特性：</p>
<ul>
<li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
<li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li>
</ul>
<p>history 模式的实现原理：</p>
<p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br><span class="line"><span class="built_in">window</span>.history.replaceState(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br></pre></td></tr></table></figure>

<p>history 路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
<li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li><code>history.pushState()</code> 或 <code>history.replaceState()</code> 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>
<h2 id="Vue-3-0"><a href="#Vue-3-0" class="headerlink" title="Vue 3.0"></a>Vue 3.0</h2><p><strong>1）监测机制的改变</strong></p>
<p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p>
<ul>
<li>只能监测属性，不能监测对象</li>
<li>检测属性的添加和删除；</li>
<li>检测数组索引和长度的变更；</li>
<li>支持 Map、Set、WeakMap 和 WeakSet。</li>
</ul>
<p>新的 observer 还提供了以下特性：</p>
<ul>
<li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li>
<li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li>
<li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li>
<li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li>
<li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li>
</ul>
<p><strong>（2）模板</strong></p>
<p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p>
<p>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p>
<p><strong>（3）对象式的组件声明方式</strong></p>
<p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p>
<p>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p>
<p><strong>（4）其它方面的更改</strong></p>
<p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p>
<ul>
<li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li>
<li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li>
<li>基于 treeshaking 优化，提供了更多的内置功能。</li>
</ul>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><strong>public &gt; index.html</strong> 整个vue project的入口，因为Vue是一个单页面网页的框架，这个文件中的<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>就是整个Vue app的占位符。</p>
<p><strong>src &gt; main.js</strong> 整个Vue app的入口</p>
<p><strong>src &gt; App.vue</strong> <code>&lt;style&gt;</code>里面写一些全局的css，以及使用的最大的（几个）模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>; <span class="comment">//导入Vue</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span> <span class="comment">//导入这个Vue component（app）</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App) <span class="comment">//等同于 render (createElement)&#123;return createElement(App)&#125;，h是createElement（生成DOM元素）的缩写</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="监听-更新"><a href="#监听-更新" class="headerlink" title="监听/更新"></a>监听/更新</h1><h2 id="computed-vs-watch"><a href="#computed-vs-watch" class="headerlink" title="computed vs watch"></a>computed vs watch</h2><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>
<p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h2 id="Vue-检测不到的数组变动"><a href="#Vue-检测不到的数组变动" class="headerlink" title="Vue 检测不到的数组变动"></a>Vue 检测不到的数组变动</h2><p>1）直接使用索引修改数组项：vm.items[indexOfItem] = newValue</p>
<p>解决方案：Vue.set(vm.items, indexOfItem, newValue) 或 vm.$set(vm.items, indexOfItem, newValue) </p>
<p>2）修改数组的长度：vm.items.length = newLength</p>
<p>解决方案：vm.items.splice(newLength)</p>
<h2 id="Proxy-vs-Object-defineProperty"><a href="#Proxy-vs-Object-defineProperty" class="headerlink" title="Proxy vs Object.defineProperty"></a>Proxy vs Object.defineProperty</h2><p>我们通常使用Proxy来修改set/get来改变设置和取值的时候的行为。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
<p><strong>Proxy 的优势如下:</strong></p>
<ul>
<li>Proxy 可以直接监听对象而非属性；</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li>
</ul>
<p><strong>Object.defineProperty 的优势如下:</strong></p>
<ul>
<li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li>
</ul>
<h2 id="Vue-set-vm-set"><a href="#Vue-set-vm-set" class="headerlink" title="Vue.set() = vm.$set()"></a>Vue.set() = vm.$set()</h2><p>受现代 JavaScript 的限制 ，Vue <strong>无法检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>
<p>如果目标是数组，直接使用数组的 splice 方法触发响应式；</p>
<p>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用   defineReactive 方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ol>
<li>new Vue() 实例化Vue对象，初始化 events 和 lifecycle</li>
<li>beforeCreate() -&gt; init injection &amp; reactivity </li>
<li>created() -&gt; 检查el和template -&gt; 编译模版，把data对象里的数据和Vue语法声明的模版编译成浏览器可读的HTML </li>
<li>beforeMount() 现在页面没有内容，还没开始挂载-&gt; 创建 vm.el 并且代替 el，用编译好的HTML替换掉 el 属性所指向的DOM</li>
<li>mounted() ：编译好的HTML挂载到页面完成后执行的事件钩子，一般做一些ajax请求获取数据进行数据初始化，在整个实例中只会被执行一次</li>
<li>beforeUpdate() 和 updated()：VM 实时监控数据的变化，并随之更新DOM</li>
<li>vm.destroy() 实例销毁 -&gt; 拆除数据监听，子组件和事件监听</li>
</ol>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用。此时调用异步请求最佳：能更快获取到服务端数据，SSR也发生在此</td>
</tr>
<tr>
<td>beforeMount</td>
<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td>mounted</td>
<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后，调用该钩子可以调用DOM了</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td>update</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>activited</td>
<td>keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td>beforeDestory</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td>destoryed</td>
<td>组件销毁后调用</td>
</tr>
</tbody></table>
<h2 id="父子组件的执行顺序"><a href="#父子组件的执行顺序" class="headerlink" title="父子组件的执行顺序"></a>父子组件的执行顺序</h2><p><strong>加载渲染过程</strong></p>
<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount </p>
<p>-&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted </p>
<p>-&gt; 父 mounted</p>
<p><strong>子组件更新过程</strong></p>
<p>父 beforeUpdate </p>
<p>-&gt; 子 beforeUpdate -&gt; 子 updated </p>
<p>-&gt; 父 updated</p>
<p><strong>父组件更新过程</strong></p>
<p>父 beforeUpdate -&gt; 父 updated</p>
<p><strong>销毁过程</strong></p>
<p>父 beforeDestroy </p>
<p>-&gt; 子 beforeDestroy -&gt; 子 destroyed </p>
<p>-&gt; 父 destroyed</p>
<h2 id="父组件监听子组件的生命周期"><a href="#父组件监听子组件的生命周期" class="headerlink" title="父组件监听子组件的生命周期"></a>父组件监听子组件的生命周期</h2><p>1）手动emit</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;Child @mounted=<span class="string">&quot;doSomething&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="built_in">this</span>.$emit(<span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）使用@hook来监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Child @hook:mounted&#x3D;&quot;doSomething&quot; &gt;&lt;&#x2F;Child&gt;</span><br><span class="line"></span><br><span class="line">doSomething() &#123;</span><br><span class="line">   console.log(&#39;父组件监听到 mounted 钩子函数 ...&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等，仅有的例外是像 <code>el</code> 这样根实例特有的选项。</p>
<h2 id="Component-的单向数据流"><a href="#Component-的单向数据流" class="headerlink" title="Component 的单向数据流"></a>Component 的单向数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<p>两种需要修改prop的场景</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],<span class="comment">//初始值</span></span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],<span class="comment">//需要进行转换</span></span><br><span class="line">computed: &#123;<span class="comment">//定义计算属性</span></span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue-组件间通信"><a href="#Vue-组件间通信" class="headerlink" title="Vue 组件间通信"></a>Vue 组件间通信</h2><p><strong>（1）<code>props / $emit</code>  适用 父子组件通信</strong></p>
<p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p>
<p>子 =&gt; 父：<code>$emit</code> =&gt; <code>@</code> + <code>$event</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span>&gt;</span><span class="comment">&lt;!--子抛出了enlarge-text事件和0.1--&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;postFontSize += $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="comment">&lt;!--第一种：父监听enlarge-text事件，用$event接受抛出的参数--&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;onEnlargeText&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第二种：调用onEnlargeText这一个方法，抛出的值作为参数传入这个方法--&gt;</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  onEnlargeText: function (enlargeAmount) &#123;</span><br><span class="line">    this.postFontSize += enlargeAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父 =&gt; 子：<code>v-bind:</code> =&gt; <code>props</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">props: [&#39;title&#39;], &#x2F;&#x2F;子组件定义props</span><br><span class="line"></span><br><span class="line">&lt;blog-post v-bind:title&#x3D;&quot;post.title&quot; ... &gt;&lt;!--父组件用v-bind传递参数--&gt;</span><br></pre></td></tr></table></figure>

<p><strong>（2）<code>ref</code> 与 <code>$parent / $children</code> 适用 父子组件通信</strong></p>
<ul>
<li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
<li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li>
</ul>
<p><strong>（3）<code>EventBus （$emit / $on）</code>  适用于 父子、隔代、兄弟组件通信</strong></p>
<p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p>
<p><strong>（4）<code>$attrs</code>/<code>$listeners</code> 适用于 隔代组件通信</strong></p>
<ul>
<li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li>
<li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</li>
</ul>
<p><strong>（5）<code>provide / inject</code> 适用于 隔代组件通信</strong></p>
<p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<p><strong>（6）Vuex  适用于 父子、隔代、兄弟组件通信</strong></p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li>
</ul>
<h2 id="slot-vs-props"><a href="#slot-vs-props" class="headerlink" title="slot vs props"></a>slot vs props</h2><p>使用slot是一种更美观简化的把父级元素传递到子组件上的方法，一般slot的内容是可以看到的内容。</p>
<p>slot最大的优点是：可以接收HTML代码，甚至其他组件。但是props如果有太多的数据传输会非常的乱，而且灵活性差很多。</p>
<p>slot 片段</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;button-text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="comment">&lt;!--组件定义--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:button-text</span>&gt;</span><span class="comment">&lt;!--使用组件--&gt;</span></span><br></pre></td></tr></table></figure>

<p>props 片段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    buttonText: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#39;&#39;,</span><br><span class="line">    &#125;, ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;使用这一组件</span><br><span class="line">&lt;CustomButtonWithProps</span><br><span class="line">    :button-text&#x3D;&quot;&#39;I\&#39;m a button&#39;&quot; ...</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="全局-局部注册"><a href="#全局-局部注册" class="headerlink" title="全局/局部注册"></a>全局/局部注册</h2><p>1）导入，首先<code>export default</code>把文件作为component导出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 导出component</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不是component定义的地方使用它<code>import ... from ...</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">&#x27;./ComponentA.vue&#x27;</span><span class="comment">// 导入component</span></span><br></pre></td></tr></table></figure>

<p>2）全局注册，任何根实例和子组件都可以使用，在组件内部也可以互相使用，在根Vue实例创建之前注册好</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;component-a&#x27;</span>, &#123; &#125;)</span><br><span class="line">Vue.component(<span class="string">&#x27;component-b&#x27;</span>, &#123; &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li>
<li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><p>解除DOM元素内部的限制，有一些DOM元素里面只能放特定的元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这里面只能放&lt;tr&gt;，使用is这一个参数来声明这里实际上是用哪一个component--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span> = <span class="string">&quot;blog-post-row&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>什么情况下没有这种限制？</p>
<ul>
<li>使用字符串<code>template: &#39;...&#39;</code></li>
<li>单文件组件（.vue）</li>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
</ul>
<h2 id="class，style的动态绑定"><a href="#class，style的动态绑定" class="headerlink" title="class，style的动态绑定"></a>class，style的动态绑定</h2><p>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class&#x3D;&quot;&#123; active: isActive, &#39;text-danger&#39;: hasError &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">    return&#123;</span><br><span class="line">    isActive: true,</span><br><span class="line">    hasError: false</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div v-bind:style&#x3D;&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">    return&#123;</span><br><span class="line">    activeColor: &#39;red&#39;,</span><br><span class="line">    fontSize: 30</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class&#x3D;&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">    return&#123;</span><br><span class="line">    isActive: true,</span><br><span class="line">        activeClass: &#39;active&#39;,</span><br><span class="line">      errorClass: &#39;text-danger&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div v-bind:style&#x3D;&quot;[styleColor, styleSize]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">    return&#123;</span><br><span class="line">    styleColor: &#123;</span><br><span class="line">       color: &#39;red&#39;</span><br><span class="line">     &#125;,</span><br><span class="line">    styleSize:&#123;</span><br><span class="line">       fontSize:&#39;23px&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="v-show-vs-v-if"><a href="#v-show-vs-v-if" class="headerlink" title="v-show vs v-if"></a>v-show vs v-if</h2><p><strong>v-if</strong> 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h2 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h2><ol>
<li>将等号后面的data与这个input的value进行绑定</li>
<li>绑定input的事件与这个input的value的更新</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span> = <span class="string">&quot;searchText&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span> = <span class="string">&quot;searchText&quot;</span> <span class="attr">v-on:input</span> = <span class="string">&quot;searchText = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h3><p>监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，<u>利用 Object.defineProperty() 对属性都加上 setter 和 getter</u>。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p>
<p>解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p>
<p>订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p>
<p>订阅器 Dep：<code>dep.notify()</code>订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p>
<img src="/Users/easonchiu/Library/Application Support/typora-user-images/截屏2020-08-27 上午8.38.52.png" alt="截屏2020-08-27 上午8.38.52" style="zoom:50%;" />



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//observe 数组</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])  <span class="comment">// observe 功能为监测数据的变化</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) <span class="comment">// observe 功能为监测数据的变化</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>shallow</code> 为 false 的情况，会对新设置的值变成一个响应式对象</p>
<h1 id="TodoList-实战"><a href="#TodoList-实战" class="headerlink" title="TodoList 实战"></a>TodoList 实战</h1><h2 id="完成一项"><a href="#完成一项" class="headerlink" title="完成一项"></a>完成一项</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&quot;todo-item&quot;</span> <span class="attr">v-bind:class</span> = <span class="string">&quot;&#123;&#x27;is-complete&#x27;:todo.completed&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--将is-complete这个class与todo.completed的值相绑定--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">v-on:change</span> = <span class="string">&quot;markComplete&quot;</span> <span class="attr">:checked</span> = <span class="string">&quot;todo.completed&quot;</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!--在改变的时候调用markComplete()，checked与否与todo.completed绑定--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">&quot;TodoItem&quot;</span>,</span></span><br><span class="line"><span class="javascript">        props: [<span class="string">&quot;todo&quot;</span>],</span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            markComplete()&#123;<span class="comment">//flip completed</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.todo.completed = !<span class="built_in">this</span>.todo.completed;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.is-complete</span>&#123;<span class="comment">/*按这个class来加上横线*/</span></span></span><br><span class="line">    text-decoration: line-through;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除一项"><a href="#删除一项" class="headerlink" title="删除一项"></a>删除一项</h2><p>在TodoItem.vue中，@（v-on）绑定了事件click，抛出事件del-todo和参数todo.id</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;$emit(&#x27;del-todo&#x27;, todo.id)&quot;</span> <span class="class"><span class="keyword">class</span> </span>= <span class="string">&quot;del&quot;</span>&gt;x&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>在Todos.vue中，@（v-on）绑定了事件del-todo，抛出事件del-todo和参数todo.id</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;todoItem v-bind:todo = <span class="string">&quot;todo&quot;</span> @del-todo = <span class="string">&quot;$emit(&#x27;del-todo&#x27;, todo.id)&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>在App.vue中，@（v-on）绑定了事件del-todo，运行deleteTodo + 参数todo.id</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Todos v-bind:todos = <span class="string">&quot;todos&quot;</span> @del-todo = <span class="string">&quot;deleteTodo&quot;</span>/&gt;</span><br><span class="line">  </span><br><span class="line">methods:&#123;</span><br><span class="line">    deleteTodo(id)&#123;</span><br><span class="line">    <span class="comment">//用一个filter，只保留那些id不等于给定的id的todo，这个规则是一个匿名函数</span></span><br><span class="line">        <span class="built_in">this</span>.todos = <span class="built_in">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id !== id);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>要使用axios，先进行安装<code>$ npm install axios</code></p>
<p>然后改造写死的数据结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    todos: []</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要在created钩子函数中获取todos</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  axios.get(<span class="string">&#x27;https://jsonplaceholder.typicode.com/todos?_limit=5&#x27;</span>) <span class="comment">//这个是返回一个Promise</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">this</span>.todos = res.data)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造删除函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deleteTodo(id) &#123;</span><br><span class="line">  axios.delete(<span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;id&#125;</span>`</span>)<span class="comment">//使用`来给地址id赋值</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">this</span>.todos = <span class="built_in">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id !== id))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造AddTodo.vue</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form @submit = <span class="string">&quot;addTodo&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">addTodo(e) &#123; <span class="comment">//我们监听的是submit这个事件，用e取出来</span></span><br><span class="line">  e.preventDefault(); <span class="comment">//禁止submit的默认请求</span></span><br><span class="line">  <span class="keyword">const</span> newTodo = &#123;</span><br><span class="line">    title: <span class="built_in">this</span>.title,</span><br><span class="line">    completed: <span class="literal">false</span></span><br><span class="line">  &#125; <span class="comment">//这里不再需要手动添加id了</span></span><br></pre></td></tr></table></figure>

<p>改造新增函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">addTodo(newTodo) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    title,</span><br><span class="line">    completed</span><br><span class="line">  &#125; = newTodo;</span><br><span class="line">  axios.post(<span class="string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>, &#123;</span><br><span class="line">    title,</span><br><span class="line">    completed</span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">this</span>.todos = [...this.todos, res.data]) <span class="comment">//... 意味着spread并获取所有的this.todos属性，然后后面我们传递的属性会覆盖现有的属性</span></span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>禁止 Vue 劫持我们的数据。可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</li>
<li>图片资源懒加载：对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueLazyload <span class="keyword">from</span> <span class="string">&#x27;vue-lazyload&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueLazyload)</span><br><span class="line"></span><br><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">preLoad: <span class="number">1.3</span>,</span><br><span class="line">error: <span class="string">&#x27;dist/error.png&#x27;</span>,</span><br><span class="line">loading: <span class="string">&#x27;dist/loading.gif&#x27;</span>,</span><br><span class="line">attempt: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//使用v-lazy代替img</span></span><br><span class="line">&lt;img v-lazy=<span class="string">&quot;/static/img/1.png&quot;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>路由懒加载：Vue  是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第三方插件的按需引入：我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 <code>babel-plugin-component</code> ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：<br>修改.babelrc</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [[<span class="string">&quot;es2015&quot;</span>, &#123; <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">&quot;component&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;element-ui&quot;</span>,</span><br><span class="line">          <span class="string">&quot;styleLibraryName&quot;</span>: <span class="string">&quot;theme-chalk&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入部分组件到 main.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Select)</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<h2 id="Webpack-优化"><a href="#Webpack-优化" class="headerlink" title="Webpack 优化"></a>Webpack 优化</h2><ul>
<li>图片压缩</li>
</ul>
<p>在 vue 项目中除了可以在 <code>webpack.config.js</code> 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 <code>image-webpack-loader</code>来压缩图片</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">  use:[</span><br><span class="line">    &#123;</span><br><span class="line">    loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: <span class="number">10000</span>, <span class="comment">//小于limit的转成base64</span></span><br><span class="line">      name: utils.assetsPath(<span class="string">&#x27;img/[name].[hash:7].[ext]&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">&#x27;image-webpack-loader&#x27;</span>,<span class="comment">//用于压缩照片</span></span><br><span class="line">      options: &#123;</span><br><span class="line">        bypassOnDebug: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>减少ES6 =&gt; ES5的冗余代码：修改 .babelrc 配置文件为</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;transform-runtime&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>提取公共代码：如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p>
<ul>
<li><p>相同的资源被重复加载，浪费用户的流量和服务器的成本。</p>
</li>
<li><p>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。</p>
<p>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">&#x27;vendor&#x27;</span>,</span><br><span class="line">  minChunks: <span class="function"><span class="keyword">function</span>(<span class="params">module, count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">      <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">        path.join(__dirname, <span class="string">&#x27;../node_modules&#x27;</span>)</span><br><span class="line">      ) === <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 抽取出代码模块的映射关系</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">&#x27;manifest&#x27;</span>,</span><br><span class="line">  chunks: [<span class="string">&#x27;vendor&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>提取css：当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。</li>
<li>使用sourceMap优化debug：可以选<strong>cheap</strong>： 添加 cheap 的基本类型来忽略打包前后的列信息；<strong>module</strong> ：定位到bug的源代码具体的位置</li>
<li>输出结果分析：Webpack 输出的代码可读性非常差而且文件非常大，可以使用<code>webpack-bundle-analyzer</code>可视化分析工具</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  <span class="keyword">var</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;</span><br><span class="line">  webpackConfig.plugins.push(<span class="keyword">new</span> BundleAnalyzerPlugin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Webpack-基础"><a href="#Webpack-基础" class="headerlink" title="Webpack 基础"></a>Webpack 基础</h3><ul>
<li>把css/js的文件打包起来bundle.css/bundle.js（不需要担心js导入的先后顺序的出错）</li>
<li>将高级的ES6 =&gt; ES5</li>
</ul>
<p>第一步：安装webpack</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init &#x2F;&#x2F;package.json</span><br><span class="line">$ npm install webpack --save-dev</span><br></pre></td></tr></table></figure>

<p>第二步：修改<code>package.json</code>的scripts的<code>build</code>为<code>webpack + 应用入口 + 输出</code>，可以在末尾加上<code>-p</code>来使用production mode</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack src/app.js dist/bundle.js&quot;,</span><br><span class="line">  &quot;build-prod&quot;: &quot;webpack src/app.js dist/bundle.js -p&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：在app.js加上<code>import &#123;XXX, YYY&#125; from &#39;./fileName&#39; </code>，在依赖的其他js文件上加上<code>export XXX; export YYY;</code></p>
<p>第四步：<code>$ npm run build</code> 或 <code>npm run build:prod</code></p>
<p><strong>webpack-dev-server</strong></p>
<p>在自己的电脑上，如果是普通的webpack就没办法看到网络传输的效果，所有的文件都是本地的（0B），安装了webpack-dev-server之后就可以在本地模拟服务器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot; : &quot;webpack-dev-server --entry ./src/app.js --output-filename ./dist/bundle.js&quot;</span><br></pre></td></tr></table></figure>

<p>改成webpack-dev-server，增加–entry和–output-filename，在地址前加上./</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span> <span class="built_in">exports</span> &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),<span class="comment">//需要是absolute path，所以加上__dirname</span></span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    publicPath: <span class="string">&#x27;/dist&#x27;</span><span class="comment">//webpack-dev-server需要特意说明path的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>module（loader）</strong></p>
<p>现在我们想要将css打包并且load，我们需要安装<code>css-loader</code> 和 <code>style-loader</code></p>
<p>然后我们在app.js里面增加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../css/main.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../css/input-elements.css&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在webpack.config.js里的module exports里增加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">//把css加入到html中</span></span><br><span class="line">        <span class="string">&#x27;css-loader&#x27;</span> <span class="comment">//在js加载css</span></span><br><span class="line">        <span class="comment">//use是从后往前的</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Web-优化"><a href="#Web-优化" class="headerlink" title="Web 优化"></a>Web 优化</h2><ul>
<li>开启gzip：接近70%的压缩率</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compression = <span class="built_in">require</span>(<span class="string">&#x27;compression&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(compression())</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用CDN：通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。</p>
</li>
<li><p>使用 Chrome Performance 查找性能瓶颈</p>
<ul>
<li>打开 Chrome 开发者工具，切换到 Performance 面板</li>
<li>点击 Record 开始录制</li>
<li>刷新页面或展开某个节点</li>
<li>点击 Stop 停止录制</li>
</ul>
</li>
<li><p>强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</p>
<p>  比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p>
</li>
</ul>

  </div>
</article>



      </div>
      
       <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="../home/">Home</a></li>
         
          <li><a href="../about/">About</a></li>
         
          <li><a href="../archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/tzvetkov75">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">Vue 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-number">1.1.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-gt-Observable"><span class="toc-number">1.1.1.</span> <span class="toc-text">Promise &#x3D;&gt; Observable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-number">1.2.</span> <span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E9%9D%A2-SPA"><span class="toc-number">1.3.</span> <span class="toc-text">单页面 SPA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">1.4.</span> <span class="toc-text">虚拟DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Key%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">Key的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data"><span class="toc-number">1.5.</span> <span class="toc-text">Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex"><span class="toc-number">1.6.</span> <span class="toc-text">vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-SSR"><span class="toc-number">1.7.</span> <span class="toc-text">Vue SSR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router"><span class="toc-number">1.8.</span> <span class="toc-text">vue-router</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-3-0"><span class="toc-number">1.9.</span> <span class="toc-text">Vue 3.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.10.</span> <span class="toc-text">文件结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E5%90%AC-%E6%9B%B4%E6%96%B0"><span class="toc-number">2.</span> <span class="toc-text">监听&#x2F;更新</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#computed-vs-watch"><span class="toc-number">2.1.</span> <span class="toc-text">computed vs watch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%88%B0%E7%9A%84%E6%95%B0%E7%BB%84%E5%8F%98%E5%8A%A8"><span class="toc-number">2.2.</span> <span class="toc-text">Vue 检测不到的数组变动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy-vs-Object-defineProperty"><span class="toc-number">2.3.</span> <span class="toc-text">Proxy vs Object.defineProperty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-set-vm-set"><span class="toc-number">2.4.</span> <span class="toc-text">Vue.set() &#x3D; vm.$set()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">父子组件的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.2.</span> <span class="toc-text">父组件监听子组件的生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Component-%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">4.1.</span> <span class="toc-text">Component 的单向数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">4.2.</span> <span class="toc-text">Vue 组件间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slot-vs-props"><span class="toc-number">4.3.</span> <span class="toc-text">slot vs props</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C"><span class="toc-number">4.4.</span> <span class="toc-text">全局&#x2F;局部注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive"><span class="toc-number">4.5.</span> <span class="toc-text">keep-alive</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#is"><span class="toc-number">5.1.</span> <span class="toc-text">is</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class%EF%BC%8Cstyle%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">5.2.</span> <span class="toc-text">class，style的动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-show-vs-v-if"><span class="toc-number">5.3.</span> <span class="toc-text">v-show vs v-if</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-model-%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text">v-model 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">双向绑定原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TodoList-%E5%AE%9E%E6%88%98"><span class="toc-number">6.</span> <span class="toc-text">TodoList 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%B8%80%E9%A1%B9"><span class="toc-number">6.1.</span> <span class="toc-text">完成一项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E9%A1%B9"><span class="toc-number">6.2.</span> <span class="toc-text">删除一项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Axios"><span class="toc-number">6.3.</span> <span class="toc-text">Axios</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">代码优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack-%E4%BC%98%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">Webpack 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack-%E5%9F%BA%E7%A1%80"><span class="toc-number">7.2.1.</span> <span class="toc-text">Webpack 基础</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.</span> <span class="toc-text">Web 优化</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2020/09/01/Vue-notes/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yoursite.com/2020/09/01/Vue-notes/&text=Vue notes"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2020/09/01/Vue-notes/&title=Vue notes"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2020/09/01/Vue-notes/&is_video=false&description=Vue notes"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Vue notes&body=Check out this article: http://yoursite.com/2020/09/01/Vue-notes/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yoursite.com/2020/09/01/Vue-notes/&title=Vue notes"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yoursite.com/2020/09/01/Vue-notes/&title=Vue notes"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2020/09/01/Vue-notes/&title=Vue notes"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yoursite.com/2020/09/01/Vue-notes/&title=Vue notes"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2020/09/01/Vue-notes/&name=Vue notes&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

      
      <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Eason
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="../home/">Home</a></li>
         
          <li><a href="../about/">About</a></li>
         
          <li><a href="../archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/tzvetkov75">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

      
<script src="../lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="../js/main.js"></script>

<!-- Google Analytics -->

<!-- Disqus Comments -->


    </div>
</body>
</html>
